<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="" xml:lang="">
  <head>
    <title>Strings and regex in R</title>
    <meta charset="utf-8" />
    <meta name="date" content="2019-05-27" />
    <link href="libs/remark-css/default.css" rel="stylesheet" />
    <link rel="stylesheet" href="custom-fonts.css" type="text/css" />
  </head>
  <body>
    <textarea id="source">
class: center, middle, inverse, title-slide

# Strings and regex in R
## <a href="https://github.com/ecodatasci-tlv/strings-and-regex" class="uri">https://github.com/ecodatasci-tlv/strings-and-regex</a>
### 2019-05-27

---



# When does it come up?

- data stored as notes
- non-uniformly formatted data
- filenames
- almost everywhere

---

# What are strings?

Strings (character types) = pretty much anything surrounded by quotes

**Double quotes** are the preferred style unless your text contains double quotes

.center[
![](https://media.giphy.com/media/xTiN0z1dTpeedhds8o/giphy.gif)
]

---

.center[.img-med[
![](https://media.giphy.com/media/HUjc0sbfgaInK/giphy.gif)
]]

### `"Keeps away the nargles."`  

--
### `'Luna whispered, "Keeps away the nargles."'`  

--
### `"Luna's eyes widened, and she whispered, \"Keeps away the nargles.\""`


---

# What's with the slash?

.center[.img-big[
![](https://media.giphy.com/media/gCwXh8EHKKfMk/giphy.gif)
]]
 
---

# Escaped characters

Special characters that may have an alternate meaning

In our previous case: is `"` literally a double-quote (chook-chik) or is it marking a character string?  

--

Some other examples:

`\n` = new line  
`\t` = tab  
`\\` = backslash  

---

# Check your escapes with `writeLines()`


```r
writeLines("Nitwit! \n\tBlubber! \n\t\tOddment! \n\U1F9D9\t\t\tTweak!")
```

```
## Nitwit! 
## 	Blubber! 
## 		Oddment! 
## ðŸ§™			Tweak!
```

_You can also write emojis (or Hebrew letters) this way!_

---

# UTF-8 

Character-encoding system of choice but not fully supported by Windows (yet); this is how you can write in Hebrew, English, Chinese, and emojis in one sentence

Want to write in Hebrew? If regular Hebrew doesn't work, you can use the code:


```r
writeLines("\U05DB\U05EA\U05D1") 
```

```
## ×›×ª×‘
```

```r
# write the letters-codes left-to-right but it prints right-to-left
```

---

class: inverse

# stringr

.center[
![](https://stringr.tidyverse.org/logo.png)

https://stringr.tidyverse.org  

_A consistent, simple and easy-to-use set of wrappers around the `stringi` package._
]

---

# General pattern

.center[.xlarge[
str_.gray[verb](.gray[text], .gray[...]) 
]] 

.large[
text = character string or vector

... = additional arguments include `pattern` to match or string to replace with
]
---

# Functions for the day

.large[
- `str_count()`
- `str_detect()`
- `str_subset()`
- `str_view()`
- `str_extract()`, `str_remove()`, `str_replace()`
]

---

# Let's get some data


```r
# from the rcorpora package
spells &lt;- read_rds("data/spells.rds")

(incantation &lt;- spells$incantation[1:5])
```

```
## [1] "Accio"     "Aguamenti" "Alohomora" "Anapneo"   "Aparecium"
```

---

# Warm up


```r
# often a useful first step to avoid dealing with capitals
str_to_lower(incantation) 
```

```
## [1] "accio"     "aguamenti" "alohomora" "anapneo"   "aparecium"
```

```r
str_count(incantation)
```

```
## [1] 5 9 9 7 9
```

```r
str_glue('Hermione shouted, "{incantation}!"')
```

```
## Hermione shouted, "Accio!"
## Hermione shouted, "Aguamenti!"
## Hermione shouted, "Alohomora!"
## Hermione shouted, "Anapneo!"
## Hermione shouted, "Aparecium!"
```

---

# Level 2: add a pattern


```r
str_detect(incantation, "o")
```

```
## [1]  TRUE FALSE  TRUE  TRUE FALSE
```

```r
str_subset(incantation, "o")
```

```
## [1] "Accio"     "Alohomora" "Anapneo"
```

--


```r
str_extract(incantation, "o.")
```

```
## [1] NA   NA   "oh" NA   NA
```

```r
str_replace(incantation, "o", "!")
```

```
## [1] "Acci!"     "Aguamenti" "Al!homora" "Anapne!"   "Aparecium"
```

---

# Once more, with feeling!


```r
str_extract_all(incantation, "o.")
```

```
## [[1]]
## character(0)
## 
## [[2]]
## character(0)
## 
## [[3]]
## [1] "oh" "om" "or"
## 
## [[4]]
## character(0)
## 
## [[5]]
## character(0)
```

---

# Once more, with feeling!


```r
str_replace_all(incantation, "o", "!")
```

```
## [1] "Acci!"     "Aguamenti" "Al!h!m!ra" "Anapne!"   "Aparecium"
```

---

class: exercise

# Your turn

How many `object`s are there in the effect description? Replace `object` with a different noun. 


```r
spells
```

```
## # A tibble: 91 x 3
##   incantation effect                     type 
##   &lt;chr&gt;       &lt;chr&gt;                      &lt;chr&gt;
## 1 Accio       Summons an object          Charm
## 2 Aguamenti   Shoots water from wand     Charm
## 3 Alohomora   Opens locked objects       Charm
## 4 Anapneo     Clears the target's airway Spell
## 5 Aparecium   Reveals invisible ink      Spell
## # â€¦ with 86 more rows
```


---

class: inverse, center, middle

.xlarge[regex]

## regular expresions

---

# regex helpers

.center[.xlarge[`str_view_all()`]] 

and `str_view()` are your friends

Other resources:

- [regex101](https://regex101.com) - interepret regex
- [regexplain](https://www.garrickadenbuie.com/project/regexplain/) - interpret and write regex (lots of cheatsheets)
- [rex](https://github.com/kevinushey/rex) package - "friendly" regex
- [rebus](https://cran.r-project.org/web/packages/rebus/rebus.pdf) pacjkage - "friendly" regex

---

# Key expressions that I use
  
`.` = anything  
`*` = 0 or more  
`+` = 1 or more  
  
`^` = start  
`$` = end  
  
`[a-z]` = any lower case letters  
`[0-9]` = any number from 0 to 9

variations on the theme:  
`[09-]` = 0, 9, or -

---

class: exercise

# mini quiz



---

# how about NOT

`[^a-z]` the caret ("hat") shows up again!  this time, with a different meaning

.center[.img-big[
![](https://media.giphy.com/media/gbErpwcLlizvi/giphy.gif)
]]

---

`\w` word  

---



---


```r
str_split(spells$effect[1:3], " ")
```

```
## [[1]]
## [1] "Summons" "an"      "object" 
## 
## [[2]]
## [1] "Shoots" "water"  "from"   "wand"  
## 
## [[3]]
## [1] "Opens"   "locked"  "objects"
```

```r
str_match(spells$effect[1:3], "(\\w+) (\\w+)")
```

```
##      [,1]           [,2]      [,3]    
## [1,] "Summons an"   "Summons" "an"    
## [2,] "Shoots water" "Shoots"  "water" 
## [3,] "Opens locked" "Opens"   "locked"
```
    </textarea>
<style data-target="print-only">@media screen {.remark-slide-container{display:block;}.remark-slide-scaler{box-shadow:none;}}</style>
<script src="https://remarkjs.com/downloads/remark-latest.min.js"></script>
<script src="https://platform.twitter.com/widgets.js"></script>
<script>var slideshow = remark.create({
"highlightStyle": "github",
"highlightLines": true,
"ratio": "16:9"
});
if (window.HTMLWidgets) slideshow.on('afterShowSlide', function (slide) {
  window.dispatchEvent(new Event('resize'));
});
(function(d) {
  var s = d.createElement("style"), r = d.querySelector(".remark-slide-scaler");
  if (!r) return;
  s.type = "text/css"; s.innerHTML = "@page {size: " + r.style.width + " " + r.style.height +"; }";
  d.head.appendChild(s);
})(document);

(function(d) {
  var el = d.getElementsByClassName("remark-slides-area");
  if (!el) return;
  var slide, slides = slideshow.getSlides(), els = el[0].children;
  for (var i = 1; i < slides.length; i++) {
    slide = slides[i];
    if (slide.properties.continued === "true" || slide.properties.count === "false") {
      els[i - 1].className += ' has-continuation';
    }
  }
  var s = d.createElement("style");
  s.type = "text/css"; s.innerHTML = "@media print { .has-continuation { display: none; } }";
  d.head.appendChild(s);
})(document);
// delete the temporary CSS (for displaying all slides initially) when the user
// starts to view slides
(function() {
  var deleted = false;
  slideshow.on('beforeShowSlide', function(slide) {
    if (deleted) return;
    var sheets = document.styleSheets, node;
    for (var i = 0; i < sheets.length; i++) {
      node = sheets[i].ownerNode;
      if (node.dataset["target"] !== "print-only") continue;
      node.parentNode.removeChild(node);
    }
    deleted = true;
  });
})();</script>

<script>
(function() {
  var links = document.getElementsByTagName('a');
  for (var i = 0; i < links.length; i++) {
    if (/^(https?:)?\/\//.test(links[i].getAttribute('href'))) {
      links[i].target = '_blank';
    }
  }
})();
</script>

<script>
slideshow._releaseMath = function(el) {
  var i, text, code, codes = el.getElementsByTagName('code');
  for (i = 0; i < codes.length;) {
    code = codes[i];
    if (code.parentNode.tagName !== 'PRE' && code.childElementCount === 0) {
      text = code.textContent;
      if (/^\\\((.|\s)+\\\)$/.test(text) || /^\\\[(.|\s)+\\\]$/.test(text) ||
          /^\$\$(.|\s)+\$\$$/.test(text) ||
          /^\\begin\{([^}]+)\}(.|\s)+\\end\{[^}]+\}$/.test(text)) {
        code.outerHTML = code.innerHTML;  // remove <code></code>
        continue;
      }
    }
    i++;
  }
};
slideshow._releaseMath(document);
</script>
<!-- dynamically load mathjax for compatibility with self-contained -->
<script>
(function () {
  var script = document.createElement('script');
  script.type = 'text/javascript';
  script.src  = 'https://mathjax.rstudio.com/latest/MathJax.js?config=TeX-MML-AM_CHTML';
  if (location.protocol !== 'file:' && /^https?:/.test(script.src))
    script.src  = script.src.replace(/^https?:/, '');
  document.getElementsByTagName('head')[0].appendChild(script);
})();
</script>
  </body>
</html>
